/* --- start generated code --- */

// Generated by Phaser Editor 1.4.3 (Phaser v2.6.2)
/**
 * Level.
 */
function Level() {

	Phaser.State.call(this);

}

/** @type Phaser.State */
var Level_proto = Object.create(Phaser.State.prototype);
Level.prototype = Level_proto;
Level.prototype.constructor = Level;

Level.prototype.init = function() {

	this.scale.pageAlignHorizontally = true;
	this.scale.pageAlignVertically = true;
	this.stage.backgroundColor = '#ffffff';

};

Level.prototype.preload = function() {

	this.load.pack('atlas', 'assets/pack.json');

};

Level.prototype.create = function() {

	this.initScene();

	var _walls = this.add.physicsGroup(Phaser.Physics.ARCADE);

	this.add.tileSprite(800, 72, 24, 552, 'gui', 'wall.png', _walls);

	this.add.tileSprite(-24, 72, 24, 552, 'gui', 'wall.png', _walls);

	this.add.tileSprite(-24, -24, 840, 96, 'gui', 'wall.png', _walls);

	this.add.text(200, 10, 'Score :', {
		"font" : "bold 40px Arial",
		"fill" : "#ff0000"
	});

	var _score = this.add.text(344, 12, '0', {
		"font" : "bold 40px Arial",
		"fill" : "#ff0000"
	});

	var _btnBack = new btnBack(this.game, 12, 12);
	this.add.existing(_btnBack);

	var _lifes = this.add.group();
	_lifes.position.setTo(675, 20);

	var _bricks = this.add.physicsGroup(Phaser.Physics.ARCADE);
	_bricks.position.setTo(360, 120);

	var _one_png = this.add.sprite(-120, 24, 'bricks', 'one.png', _bricks);
	_one_png.data = {
		"isBreakable" : true,
		"nbTouch" : 1,
		"nbPoints" : 2
	};

	var _two_png = this.add.sprite(-48, 24, 'bricks', 'two.png', _bricks);
	_two_png.data = {
		"isBreakable" : true,
		"nbTouch" : 2,
		"nbPoints" : 4
	};

	var _three_png = this.add.sprite(24, 24, 'bricks', 'three.png', _bricks);
	_three_png.data = {
		"isBreakable" : true,
		"nbTouch" : 3,
		"nbPoints" : 6
	};

	var _four_png = this.add.sprite(96, 24, 'bricks', 'four.png', _bricks);
	_four_png.data = {
		"isBreakable" : true,
		"nbTouch" : 4,
		"nbPoints" : 8
	};

	var _unbreakable_png = this.add.sprite(
			168,
			24,
			'bricks',
			'unbreakable.png',
			_bricks);
	_unbreakable_png.data = {
		"isBreakable" : false
	};

	var _pad = this.add.sprite(384, 528, 'pad');
	_pad.anchor.setTo(0.5, 0.5);
	this.game.physics.arcade.enable(_pad);
	_pad.body.setSize(
			100.63934326171875,
			20.7698974609375,
			1.61505126953125,
			1.61505126953125);
	_pad.body.immovable = true;
	_pad.body.collideWorldBounds = true;
	_pad.body.bounce.x = 1.0;
	_pad.body.bounce.y = 1.0;
	_pad.data = {
		"lifes" : 3
	};

	var _ball = this.add.sprite(384, 500, 'ball');
	_ball.anchor.setTo(0.5, 0.5);
	this.game.physics.arcade.enable(_ball);
	_ball.body.setCircle(12.0);
	_ball.body.collideWorldBounds = true;
	_ball.body.bounce.x = 1.0;
	_ball.body.bounce.y = 1.0;
	_ball.data = {
		"isOnPad" : true
	};

	_walls.setAll("body.immovable", true);
	_bricks.setAll("body.immovable", true);

	// public fields

	this.fWalls = _walls;
	this.fScore = _score;
	this.fLifes = _lifes;
	this.fBricks = _bricks;
	this.fPad = _pad;
	this.fBall = _ball;
	this.handleGameLogic();

};

/* --- end generated code --- */

var PAD_VELOCITY = 600;

Level.prototype.render = function() {
	this.game.debug.body(this.fPad);
	this.game.debug.body(this.fBall);

	this.fBricks.forEachAlive(function(brick) {
		this.game.debug.body(brick);
	}, this);
};

Level.prototype.initScene = function() {
	// start the Arcade system
	this.game.physics.startSystem(Phaser.Physics.ARCADE);

	// create the cursors
	this.cursors = this.input.keyboard.createCursorKeys();

	// Pas de collision en bas de l'écran
	this.game.physics.arcade.checkCollision.down = false;
};

// var padForGyro;
Level.prototype.handleGameLogic = function() {
	// Évènements de la balle
	this.fBall.checkWorldBounds = true;
	this.fBall.events.onOutOfBounds.add(this.ballLost, this);
	this.game.input.onDown.add(this.releaseBall, this);

	// Mise en place des vies
	for (var i = 0; i < this.fPad.data.lifes; i++) {
		this.fLifes.create(0, 0, 'gui', 'heart.png');
	}

	this.fLifes.align(3, -1, 32, 32);

	// Prise en compte de la gyroscopie
	// window.addEventListener("deviceorientation", this.handleOrientation,
	// true);
	// padForGyro = this.fPad;
};

// Level.prototype.handleOrientation = function(e) {
// var x = e.alpha;
//
// padForGyro.body.velocity.x += x;
// };

Level.prototype.update = function() {
	if (this.input.activePointer.withinGame) {
		// Déplacement par la souris
		var minDist = 100;
		var dist = this.game.input.x - this.fPad.x;

		this.fPad.body.velocity.x = PAD_VELOCITY
				* this.game.math.clamp(dist / minDist, -1, 1);
	} else if (this.cursors.left.isDown) {
		// Déplacement gauche par le clavier
		this.fPad.body.velocity.x = -PAD_VELOCITY;
	} else if (this.cursors.right.isDown) {
		// Déplacement droite par le clavier
		this.fPad.body.velocity.x = PAD_VELOCITY;
	} else {
		this.fPad.body.velocity.x = 0;
	}

	if (this.fBall.data.isOnPad) {
		this.fBall.body.velocity.x = this.fPad.body.velocity.x;
	}

	// Déclaration des collisions
	this.physics.arcade.collide(
			this.fBall,
			this.fPad,
			this.ballTouchPad,
			null,
			this);
	this.physics.arcade.collide(this.fBall, this.fWalls);
	this.physics.arcade.collide(
			this.fBall,
			this.fBricks,
			this.ballTouchBrick,
			null,
			this);
	this.physics.arcade.collide(this.fPad, this.fWalls);
};

/**
 * La balle a touchée le pad.
 * 
 * @param {Phaser_Sprite} ball
 * @param {Phaser_Sprite} pad
 */
Level.prototype.ballTouchPad = function(ball, pad) {
	var diff = 0;
	var ballX = ball.x;
	var padX = pad.x;

	if (ballX < padX) {
		// Ball is on the left-hand side of the paddle
		diff = padX - ballX;
		ball.body.velocity.x = (-10 * diff);
	} else if (ballX > padX) {
		// Ball is on the right-hand side of the paddle
		diff = ballX - padX;
		ball.body.velocity.x = (10 * diff);
	}
};

/**
 * La balle a touchée une brique.
 * 
 * @param {Phaser_Sprite} ball
 * @param {Phaser_Sprite} brick
 */
Level.prototype.ballTouchBrick = function(ball, brick) {
	if (brick.data.isBreakable) {
		--brick.data.nbTouch;

		if (0 === brick.data.nbTouch) {
			brick.kill();
			this.fScore.text = parseInt(this.fScore.text, 10)
					+ brick.data.nbPoints;

			var bricks = this.fBricks.iterate(
					'data.isBreakable',
					true,
					Phaser.Group.RETURN_ALL);
			console.log(bricks);
		}
	}
};

/**
 * La belle est sortie de l'écran
 * 
 * @param {Phaser_Sprite} ball
 */
Level.prototype.ballLost = function(ball) {
	ball.reset(this.fPad.body.x + 24, this.fPad.y - 24);
	ball.data.isOnPad = true;

	this.fPad.data.lifes -= 1;
	var life = this.fLifes.getFirstAlive();

	if (life) {
		life.kill();
	} else {
		this.game.state.start("GameOver");
	}
};

Level.prototype.releaseBall = function() {
	if (this.fBall.data.isOnPad) {
		this.fBall.data.isOnPad = false;
		this.fBall.body.velocity.y = -300;
		this.fBall.body.velocity.x = this.game.rnd.integerInRange(-75, 75);
	}
};
